<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas {
            border: black solid 1px;
        }
    </style>
</head>

<body>
    <!-- https://github.com/thetarby/noise-js -->
    <script src="./noise-js-master/noise.js"></script>
    <!-- https://github.com/gorhill/Javascript-Voronoi/tree/master -->
    <script src="./rhill-voronoi-core.min.js"></script>
    <!-- https://github.com/mikechambers/ExamplesByMesh/blob/master/JavaScript/QuadTree/src/QuadTree.js -->
    <script src="./QuadTree.js"></script>
    <canvas id="mainCanvas" width="500px" height="500px"></canvas><br>
    <input type="number" value="10000" min="1" id="numSitesInp"> <label for="numSitesInp">Target number of sites</label>
    <br>
    <!-- <input type="number" value="100" min="1" id="numSitesYInp"> <label for="numSitesYInp">Number of sites for the Y -->
    <!-- axis</label> -->
    <p id="totalSites">Actual number of sites:</p>
    <input type="range" min="0" max="255" value="128" id="seaLevelInp"><label for="seaLevelInp" id="SLDisplay"></label>
    <br>
    <!-- <canvas id="countryCanvas" width="500px" height="500px"></canvas> -->
    <!-- <canvas id="biomeCanvas" width="500px" height="500px"></canvas> -->
    <button onclick="generate()">Generate</button><button onclick="render()">Render</button>
    <script>
        //A good portion of the voronoi diagram code was taken from https://github.com/gorhill/Javascript-Voronoi/tree/master
        let startTime = Date.now();
        function getTime() {
            return ((Date.now() - startTime) / 1000);
        }
        let cnvWidth = 1000;
        let cnvHeight = 1000;
        let mainCanvas = document.getElementById("mainCanvas");
        const canvas = document.getElementById("mainCanvas");
        const ctx = canvas.getContext("2d");
        mainCanvas.width = cnvWidth;
        mainCanvas.height = cnvHeight;
        let seaLevel = 128;
        let size = 200 * (cnvHeight / 500);
        let numSitesX = 100 * (cnvWidth / 500);
        let numSitesY = 100 * (cnvHeight / 500);
        const posterizationAmt = 2
        let hm;
        let cDiagram;
        let treemap;
        //Input handling
        /** @type {HTMLInputElement} */
        const NSInp = document.getElementById("numSitesInp")
        /** @type {HTMLLabelElement} */
        const totalSitesDisplay = document.getElementById("totalSites")
        function NSUpdate() {
            let numSites = NSInp.value
            let axisNS = Math.round(Math.sqrt(numSites))
            numSitesX = axisNS
            numSitesY = axisNS
            totalSitesDisplay.innerText = `Actual number of sites: ${numSitesX * numSitesY}`
        }
        NSUpdate()
        NSInp.oninput = NSUpdate
        /** @type {HTMLInputElement} */
        const SLDisplay = document.getElementById("SLDisplay")
        const SLInp = document.getElementById("seaLevelInp")
        function seaLevelUpdate() {
            seaLevel = SLInp.value
            SLDisplay.innerText = `Sea Level: ${seaLevel}`
        }

        SLInp.oninput = seaLevelUpdate
        seaLevelUpdate()

        function generateHeightMap(width, height, octaves) {
            let heightMap = new Uint16Array(width * height);
            heightMap.fill(0);
            let p = new Perlin(2, octaves)
            for (let y = 0; y < width; y++) {
                for (let x = 0; x < height; x++) {
                    let val = 0;
                    val = ((p.call([x / size, y / size]) + 1) / 2) * (2 ** 16);
                    val = Math.floor(val);
                    heightMap.set([val], (y * width) + x);
                }
            }
            return (heightMap)
        }
        function generateCountries(nx, ny, width, height) {
            let sites = [];
            for (let y = 0; y < ny; y++) {
                for (let x = 0; x < nx; x++) {
                    let boxWidth = width / nx;
                    let boxHeight = height / ny;
                    sites.push({ "x": (boxWidth * x) + (Math.random() * boxWidth), "y": (boxHeight * y) + (Math.random() * boxHeight) })
                }
            }
            // console.log(sites)
            let bbox = { "xl": 0, "xr": width, "yt": 0, "yb": height };
            return (new Voronoi().compute(sites, bbox));
        }
        function generateTreeMap(width, height, diagram) {
            let treemap = new QuadTree({
                x: 0,
                y: 0,
                width: width,
                height: height
            });
            let cells = diagram.cells;
            let iCell = cells.length;
            while (iCell--) {
                let bbox = cells[iCell].getBbox();
                bbox.cellid = iCell;
                treemap.insert(bbox);
            }
            return (treemap);
        }
        function cellIdFromPoint(x, y) {
            if (treemap === null) {
                treemap = generateTreeMap(cnvWidth, cnvHeight, cDiagram)
            }
            let items = treemap.retrieve({ x: x, y: y });
            let iItem = items.length;
            let cells = cDiagram.cells;
            let cell;
            let cellId;
            while (iItem--) {
                cellid = items[iItem].cellid;
                cell = cells[cellid];
                if (cell.pointIntersection(x, y) > 0) {
                    return cellid;
                }
            }
            return undefined;
        }
        function renderCell(ctx, cell, fillStyle, strokeStyle) {
            ctx.globalAlpha = 1;
            ctx.beginPath();
            var halfedges = cell.halfedges,
                nHalfedges = halfedges.length,
                v = halfedges[0].getStartpoint();
            ctx.moveTo(v.x, v.y);
            for (var iHalfedge = 0; iHalfedge < nHalfedges; iHalfedge++) {
                v = halfedges[iHalfedge].getEndpoint();
                ctx.lineTo(v.x, v.y);
            }
            ctx.fillStyle = fillStyle;
            ctx.strokeStyle = strokeStyle;
            ctx.fill();
            ctx.stroke();
        }
        function generate() {
            startTime = Date.now();
            hm = generateHeightMap(cnvWidth, cnvHeight, 5);
            console.log("Generate Height Map " + getTime());
            cDiagram = generateCountries(numSitesX, numSitesY, cnvWidth, cnvHeight);
            console.log("Generate countries " + getTime());
            render()

        }
        function render() {
            startTime = Date.now();

            console.log("Draw terrain " + getTime());
            let edges = cDiagram.edges;
            let nEdges = edges.length;
            let edge;
            let cells = cDiagram.cells;
            // ctx.strokeStyle = "rgb(0,0,0)";
            // countryCtx.strokeStyle = "rgb(0,0,0)";
            // ctx.lineWidth = 0.5;
            // countryCtx.lineWidth = 0.5;
            // ctx.beginPath()
            // countryCtx.beginPath()
            // while (nEdges--) {
            //     edge = edges[nEdges];
            //     v = edge.va;
            //     ctx.moveTo(v.x, v.y);
            //     countryCtx.moveTo(v.x, v.y);
            //     v = edge.vb;
            //     ctx.lineTo(v.x, v.y);
            //     countryCtx.lineTo(v.x, v.y);
            // }
            // ctx.stroke()
            // countryCtx.stroke()
            // for (let i = 0; i < cells.length; i++) {
            //     let site = cells[i].site;
            //     let val = hm[(Math.floor(site.y) * cnvWidth) + Math.floor(site.x)] / (2 ** 8);
            //     if (typeof val !== "number") {
            //         console.log("read error")
            //     }
            //     if (val < seaLevel) {
            //         renderCell(ctx, cells[i], "rgb(0,0,255)", "rgb(0,0,255)");
            //     }
            // }

            for (let i = 0; i < cells.length; i++) {
                let site = cells[i].site;
                let val = hm[(Math.floor(site.y) * cnvWidth) + Math.floor(site.x)] / (2 ** 8);
                if (typeof val !== "number") {
                    console.log("read error")
                }
                let color = `rgb(255,255,255)`;
                // if (val >= seaLevel) {
                renderCell(ctx, cells[i], color, "rgb(0,0,0)");
                // }
            }
            for (let y = 0; y < cnvHeight; y++) {
                let lineStrength = 0
                let prevOnLand = false
                let currOnLand = false
                for (let x = 0; x < cnvWidth; x++) {
                    let val = (hm[(y * cnvHeight) + x] / (2 ** 16)) * (2 ** 8);
                    if (val < seaLevel) {
                        val = 0;
                        ctx.fillStyle = `rgb(0,0,255)`;
                        ctx.fillRect(x, y, 1, 1);
                        currOnLand = false
                    } else {
                        currOnLand = true
                    }
                    if (prevOnLand !== currOnLand) {
                        lineStrength = 3
                    }
                    if (lineStrength > 0) {
                        ctx.fillStyle = `rgb(0,0,0)`;
                        ctx.fillRect(x, y, 1, 1);
                        lineStrength--
                    }
                    prevOnLand = currOnLand
                    // else {
                    //     // val = 128;
                    //     val = Math.floor(val / posterizationAmt) * posterizationAmt
                    //     ctx.fillStyle = `rgb(${val},${val},${val})`;
                    //     ctx.fillRect(x, y, 1, 1);

                    // }

                }
            }
            for (let x = 0; x< cnvWidth; x++) {
                let lineStrength = 0
                let prevOnLand = false
                let currOnLand = false
                for (let y = 0; y < cnvHeight; y++) {
                    let val = (hm[(y * cnvHeight) + x] / (2 ** 16)) * (2 ** 8);
                    if (val < seaLevel) {
                        currOnLand = false
                    } else {
                        currOnLand = true
                    }
                    if (prevOnLand !== currOnLand) {
                        lineStrength = 3
                    }
                    if (lineStrength > 0) {
                        ctx.fillStyle = `rgb(0,0,0)`;
                        ctx.fillRect(x, y, 1, 1);
                        lineStrength--
                    }
                    prevOnLand = currOnLand
                    // else {
                    //     // val = 128;
                    //     val = Math.floor(val / posterizationAmt) * posterizationAmt
                    //     ctx.fillStyle = `rgb(${val},${val},${val})`;
                    //     ctx.fillRect(x, y, 1, 1);

                    // }

                }
            }

            console.log("Draw countries " + getTime());
        }

    </script>
</body>

</html>